import dayjs, { Dayjs } from "dayjs";
import { Chrono, Component, Parser, ParsingComponents, ParsingResult } from "chrono-node";
import { NLDParserBase } from "../NLDParserBase";
import { getIntlMonthNames, getIntlWeekdayNames } from "../../utils/intl";
import { DateComponents } from "../../types";
import { matchAnyPattern, named, regSrc, seq } from "../../utils/regex";
import { fileURLToPath } from "url";
import { intParserForSystem, intRegexp, isNumberingSystem } from "../../utils/numberingSystems";

export type ChronoDate = ParsingComponents | ParsingResult | DateComponents | null;
export type ChronoExtractor = (context: any, match: RegExpMatchArray) => ChronoDate

export type DatePartExtractor = (m:RegExpExecArray, date:DateComponents) => DateComponents; 

interface Placeholder {
    mark:string;
    regexp:string;
    extractor:DatePartExtractor
}

interface DateFormatProject {
    pattern: string
    placeholders: Placeholder[]
}

/** a generic Date parser, completely generated from a locale and Intl information */
export default class NLDParserGeneric extends NLDParserBase {


    constructor(locale:string) {
        super(locale)
    }

    moment(date:Date):Dayjs {
        return dayjs(date).locale(this.locale)
    }
    /** @override */
    getFormattedDate(date: Date, format: string): string {
        return dayjs(date).locale(this.locale).format(format);
    }

    /** @override */
    protected override configureChrono(chrono:Chrono): Chrono {
        super.configureChrono(chrono)
        this.pushDefaultParsers(chrono)
        return chrono;
    }

    protected pushDefaultParsers(chrono:Chrono) {
        this.pushParsersForFormat(chrono, new Intl.DateTimeFormat(this.locale, {dateStyle:"full"}))
        this.pushParsersForFormat(chrono, new Intl.DateTimeFormat(this.locale, {dateStyle:"long"}))
        this.pushParsersForFormat(chrono, new Intl.DateTimeFormat(this.locale, {dateStyle:"medium"}))
        this.pushParsersForFormat(chrono, new Intl.DateTimeFormat(this.locale, {dateStyle:"short"}))
        this.pushParsersForFormat(chrono, new Intl.DateTimeFormat(this.locale, {day: "numeric", weekday: "long"}))
    }

    protected pushParsersForFormat(chrono:Chrono, format:Intl.DateTimeFormat, transliterator:(x:string) => string = (x) => x) {
        const DATE1 = new Date(2020,2,1)
        const DATE2 = new Date(2021,7,9)
        let targetDate1 = transliterator(format.format(DATE1).toLocaleLowerCase(this.locale));
        let targetDate2 = transliterator(format.format(DATE2).toLocaleLowerCase(this.locale));
        const p1 = this.makeParser(DATE1, format, transliterator)
        const p2 = this.makeParser(DATE2, format, transliterator)
        const r1 = p1.pattern(null).source
        const r2 = p2.pattern(null).source
        if (p1.pattern(null).source === p2.pattern(null).source) {
            chrono.parsers.push(p1)
        } else {
            throw new RangeError(`no common result for ${targetDate1} and ${targetDate2} : ${p1.pattern(null).source} and ${p2.pattern(null).source}`)
        }
    }

    /** creates a Dayjs format string from a date with this DateTimeFormat 
     * 
     * @param transliterator is used to transliterate non-latin writings
    */
    protected makeParser(date:Date, format:Intl.DateTimeFormat, transliterator:(x:string) => string):Parser {
        const f4 = new Intl.NumberFormat(format.resolvedOptions().locale, { minimumIntegerDigits:4, useGrouping:false})
        const f2 = new Intl.NumberFormat(format.resolvedOptions().locale, { minimumIntegerDigits:2, useGrouping:false})
        const fAny = new Intl.NumberFormat(format.resolvedOptions().locale)
        let targetDate = transliterator(format.format(date).toLocaleLowerCase(this.locale));

        const resolvedNumberingSystem = format.resolvedOptions().numberingSystem;
        const ns = isNumberingSystem(resolvedNumberingSystem) ? resolvedNumberingSystem : "latn"
        const intParser = intParserForSystem(ns)

        // we will replace parts of the strings by placeholders
        // we need those placeholders to be valid Unicode IDs (as stated in JS spec)
        // this means they must use characters in ID_Start and ID_Continue categories
        // to prevent placedholdes themselves to be altered by subsequent replacements
        // we use rare unicode (which are never generated by Intl in dates)
        // using CIRCLED LETTERS from 
        //   - Circled Latin Capital Letter A U+24B6
        //   - Circled Latin Small Letter A U+24D0	

        const _MMMM_ = "ð•„ð•„ð•„ð•„" // Mathematical Double-Struck Capital M
        const _MMM_ = "ð•„ð•„ð•„" 
        const _MM_ = "ð•„" 
        const _M_ = "ð•„" 
        const _DD_ = "ð”»ð”»" // Mathematical Double-Struck Capital D
        const _D_ = "ð”»" 
        const _YYYY_ = "ð“¨ð“¨ð“¨ð“¨"  // Mathematical Bold Script Capital Y
        const _YY_ = "ð“¨ð“¨" 
        const _dddd_ = "ð——ð——ð——ð——" // Mathematical Sans-Serif Bold Capital D
        const _ddd_ = "ð——ð——ð——"
        const _dd_ = "ð——ð——"

        let years:[string,string,string,DatePartExtractor][] = [ 
            [ transliterator(f4.format(date.getFullYear()))
                , _YYYY_
                , regSrc(named(_YYYY_, intRegexp(ns,4)))
                , (r,d) => ({...d, year: intParser(r.groups[_YYYY_])})], 
            [ transliterator(f2.format(date.getFullYear() % 100)) ,
                _YY_
                ,regSrc(named(_YY_, intRegexp(ns,2)))
                , (r,d) => ({...d, year: intParser(r.groups[_YY_])})]]

        const mmmm = getIntlMonthNames(this.locale, "long").map(x => transliterator(x.toLocaleLowerCase(this.locale)))
        const mmm = getIntlMonthNames(this.locale, "short").map(x => transliterator(x.toLocaleLowerCase(this.locale)))
        let months:[string,string,string,DatePartExtractor][] = [
            [ transliterator(mmmm[date.getMonth()].toLocaleLowerCase(this.locale))
                , _MMMM_
                , matchAnyPattern(mmmm,"","",_MMMM_)
                , (r,d) => ({...d, month:1+mmmm.indexOf(r.groups[_MMMM_].toLocaleLowerCase(this.locale)) })],
            [ transliterator(mmm[date.getMonth()].toLocaleLowerCase(this.locale))
                , _MMM_
                , matchAnyPattern(mmm,"","",_MMM_)
                , (r,d) => ({...d, month:1+mmm.indexOf(r.groups[_MMM_].toLocaleLowerCase(this.locale)) })],
            [ transliterator(getIntlMonthNames(this.locale, "2-digit")[date.getMonth()])
                , _MM_
                , regSrc(named(_MM_, intRegexp(ns)))
                , (r,d) => ({...d, month: intParser(r.groups[_MM_])})],
            [ transliterator(getIntlMonthNames(this.locale, "numeric")[date.getMonth()])
                , _M_
                , regSrc(named(_M_, intRegexp(ns)))
                , (r,d) => ({...d, month: intParser(r.groups[_M_])})]
        ]

        let days:[string,string,string,DatePartExtractor][] = [
            [transliterator(f2.format(date.getDate()))
                , _DD_
                , regSrc(named(_DD_, intRegexp(ns, 2)))
                , (r,d) => ({...d, day: intParser(r.groups[_DD_])})
            ],
            [transliterator(fAny.format(date.getDate()))
                , _D_
                , regSrc(named(_D_, intRegexp(ns)))
                , (r,d) => ({...d, day: parseInt(r.groups[_D_])})]
        ]
        const dbg1 = named("_D_", intRegexp(ns))

        const dddd = getIntlWeekdayNames(this.locale, "long").map(x => transliterator(x.toLocaleLowerCase(this.locale)))
        const ddd = getIntlWeekdayNames(this.locale, "short").map(x => transliterator(x.toLocaleLowerCase(this.locale)))
        const dd = getIntlWeekdayNames(this.locale, "narrow").map(transliterator)
        
        let weekdays:[string,string,string,DatePartExtractor][] = [
            [dddd[date.getDay()].toLocaleLowerCase(this.locale)
                , _dddd_
                , matchAnyPattern(dddd,"","",_dddd_)
                , (r,d) => ({...d, weekday: dddd.indexOf(r.groups[_dddd_].toLocaleLowerCase(this.locale))})
            ],
            [ddd[date.getDay()].toLocaleLowerCase(this.locale)
                , _ddd_
                , matchAnyPattern(ddd,"","",_ddd_)
                , (r,d) => ({...d, weekday: ddd.indexOf(r.groups[_ddd_].toLocaleLowerCase(this.locale))})
            ],
            [dd[date.getDay()].toLocaleLowerCase(this.locale)
                , _dd_
                , matchAnyPattern(dd,"","",_dd_)
                , (r,d) => ({...d, weekday: ddd.indexOf(r.groups[_dd_])})
            ]
        ]

        let project:DateFormatProject = { pattern: targetDate, placeholders: [] }
        project = this.replaceFirst(project, years)
        project = this.replaceFirst(project, months)
        project = this.replaceFirst(project, days)
        project = this.replaceFirst(project, weekdays)
        console.log(project.pattern)
        const filler = this.composeFillers(...(project.placeholders.map(x => x.extractor)));
        const reg = project.placeholders.reduce( (val:string, p:Placeholder) => val.replace(p.mark, p.regexp) , project.pattern)

        return {
            pattern: (context) => new RegExp(reg, "i"),     // always ignore case for dates
            extract: (context, m:RegExpExecArray) => filler(m, {})
        }
    }

    protected replaceFirst(project:DateFormatProject, items:[string,string, string, DatePartExtractor][]):DateFormatProject {
        
        for (let [value, mark, regexp, extractor] of items) {
            const target = seq({},/(?<!\p{L})/u,value,/(?!\p{L})/u) // only replace whole words
            let pattern = project.pattern.replace(target, mark);
            if (pattern != project.pattern) {
                console.log("from ", project.pattern, " to ", pattern)
                return {
                    pattern,
                    placeholders: [ ...project.placeholders, {mark, regexp, extractor}] 
                }
            }
        }
        return project;
    }

    protected composeFillers(...fillers:DatePartExtractor[]):DatePartExtractor {
        return (r:RegExpExecArray, d:DateComponents) => {
            let result = d;
            for (let f of fillers) {
                d = f(r,d)
            }
            return d;
        }
    }
}